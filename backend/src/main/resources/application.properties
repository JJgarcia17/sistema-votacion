# --- Configuración del Servidor ---
# Define el puerto en el que correrá Spring.
# Lo dejamos en 8080, que es el que expusimos en el Dockerfile.
server.port=8080

# --- Configuración de la Base de Datos (PostgreSQL) ---
# Le decimos a Spring que use el driver de PostgreSQL.
spring.datasource.driver-class-name=org.postgresql.Driver

# Esta es la parte clave.
# Le decimos a Spring que la URL, usuario y contraseña vendrán de variables de entorno.
# NOTA: El host es 'db', que será el nombre de nuestro servicio de base de datos en Docker.
spring.datasource.url=jdbc:postgresql://${DB_HOST:db}:${DB_PORT:5432}/${DB_NAME:votacion_db}
spring.datasource.username=${DB_USER:postgres}
spring.datasource.password=${DB_PASS:postgres}

# --- Configuración de JPA (Hibernate) ---
# Esto le dice a Hibernate que dialecto de SQL usar.
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

# 'update' significa que Hibernate intentará crear/modificar las tablas
# automáticamente basándose en nuestras clases @Entity.
# Es perfecto para desarrollo y nos ahorra crear scripts SQL.
## Nota: Usamos Flyway para controlar las migraciones de esquema.
## Cambiamos ddl-auto a 'validate' para que Hibernate valide el esquema
## y Flyway sea responsable de aplicar cambios estructurales.
spring.jpa.hibernate.ddl-auto=validate

# Configuración de Flyway
spring.flyway.enabled=true
# Permite inicializar (baseline) si la base de datos ya tiene esquema.
spring.flyway.baseline-on-migrate=true
spring.flyway.locations=classpath:db/migration

# Opcional: Muestra el SQL que Hibernate está ejecutando. Muy útil para depurar.
spring.jpa.show-sql=true